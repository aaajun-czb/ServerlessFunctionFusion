
## 环境配置

```
gradle: 4.8.1
java: 8
```

## 1. gradle 配置修改
### 修改build.gradle

~~将`build.gradle`中的`compile project(':model')`替换为`compile 'com.openfaas:model:0.1.1'`。~~

`build.gradle`中增加用于httpserver的依赖
```groovy
implementation 'com.google.guava:guava:23.0'
implementation 'com.squareup.okhttp3:okhttp:3.10.0'
implementation 'com.squareup.okio:okio:1.14.1'

implementation 'com.sun.net.httpserver:http:20070405'
```


`build.gradle`中增加内容，用于确定main函数和jar打包。同时在`plugin`中增加`id 'application'`。

```groovy
plugins {
    id 'java-library'
    id 'application'
}
```

```groovy
// Define the main class for the application
mainClassName = 'com.openfaas.function.proxy.Proxy'

jar {
    manifest { // 设置jar包的主类
        attributes(
                'Main-Class': 'com.openfaas.function.proxy.Proxy'
        )
    }
    from { // 将依赖的jar包打包到生成的jar包中
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
}
```

#### 完整内容
```groovy
/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java Library project to get you started.
 * For more details take a look at the Java Libraries chapter in the Gradle
 * user guide available at https://docs.gradle.org/4.8.1/userguide/java_library_plugin.html
 */

plugins {
    // Apply the java-library plugin to add support for Java Library
    id 'java-library'
    id 'application'
}

dependencies {
    // This dependency is exported to consumers, that is to say found on their compile classpath.
    api 'org.apache.commons:commons-math3:3.6.1'

    // This dependency is used internally, and not exposed to consumers on their own compile classpath.
    implementation 'com.google.guava:guava:23.0'
    implementation 'com.squareup.okhttp3:okhttp:3.10.0'
    implementation 'com.squareup.okio:okio:1.14.1'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'

    // https://mvnrepository.com/artifact/com.sun.net.httpserver/http
    implementation 'com.sun.net.httpserver:http:20070405'
    
    // compile project(':model')
    compile 'com.openfaas:model:0.1.1'
    compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.10.0'
    compile 'org.mongodb:mongodb-driver-sync:4.0.2'
}

// In this section you declare where to find the dependencies of your project
repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// Define the main class for the application
mainClassName = 'com.openfaas.function.proxy.Proxy'

jar {
    manifest { // 设置jar包的主类
        attributes(
                'Main-Class': 'com.openfaas.function.proxy.Proxy'
        )
    }
    from { // 将依赖的jar包打包到生成的jar包中
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
}
```
### 修改settings.gradle
将`settings.gradle`中的`rootProject.name`修改为最上层的目录名。

### 生成Gradle Wrapper
使用`gradle wrapper`生成 Gradle Wrapper，后续可以使用`gradlew`进行操作。
重新使用vscode打开，以识别文件正确的包路径。

## 2. 代码修改
### 文件移动

删除`src/test/java`下的测试文件

在`src/main/openfaas/function`下新建`handler`文件夹，之后将`src/main/openfaas/function/Handler.java`移入该文件夹下。

在`src/main/openfaas/function`下新建`proxy`文件夹，之后在该文件夹中创建`Proxy.java`文件。

### 增加Proxy代码

如果是最下游的函数，可以去掉`updateHandler`类以及`server.createContext("/update", new updateHandler());`。
#### 有update版本

```java
package com.openfaas.function.proxy;

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;

import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.MediaType;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.InputStream;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import edu.fudan.common.util.JsonUtils;
import edu.fudan.common.util.mResponse;

import com.openfaas.function.handler.Handler;

public class Proxy {
    private static final int PORT = 8080;
    private static final int MAX_REQUESTS = 3;
    private static final AtomicInteger requestCount = new AtomicInteger(0);

    public static void main(String[] args) throws IOException {
        // 创建HttpServer实例并绑定到特定地址和端口
        HttpServer server = HttpServer.create(new InetSocketAddress(PORT), 0);

        // 创建一个上下文，并指定处理器
        server.createContext("/", new InvokeHandler());
        
        // 创建一个上下文，并指定处理器，用于更新function URI
        server.createContext("/update", new updateHandler());

        // 设置服务器的线程池
        server.setExecutor(null);

        // 启动服务器
        server.start();

        System.out.println("Server is listening on port " + PORT + " with MAX_REQUESTS = " + MAX_REQUESTS);
    }

    // 定义处理器类
    static class InvokeHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            int currentCount = requestCount.incrementAndGet();

            // 将exchange转换成okhttp的Request
            Request request = httpExchangeToRequest(exchange);
            
            // 创建Handler实例并处理请求
            Handler handler = new Handler();
            mResponse mRes = handler.Handle(request);

            // 将mReponse转换成exchange进行输出
            sendResponseToExchange(mRes, exchange);
            if (currentCount >= MAX_REQUESTS) {
                exchange.getHttpContext().getServer().stop(0);
                System.out.println("Server stopped after " + currentCount + " requests");
            }
        }
    }

    // 定义处理器类，用于更新function URI
    static class updateHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            int currentCount = requestCount.incrementAndGet();

            // 将exchange转换成okhttp的Request
            Request request = httpExchangeToRequest(exchange);
            
            // 调用静态方法更新function URI
            mResponse mRes = Handler.UpdateHandle(request);

            // 将mReponse转换成exchange进行输出
            sendResponseToExchange(mRes, exchange);
            if (currentCount >= MAX_REQUESTS) {
                exchange.getHttpContext().getServer().stop(0);
                System.out.println("Server stopped after " + currentCount + " requests");
            }
        }
    }

    public static Request httpExchangeToRequest(HttpExchange exchange) throws IOException {
        String method = exchange.getRequestMethod();
        String url = exchange.getRequestURI().toString();
        try{
            Request.Builder requestBuilder = new Request.Builder().url("http://locoalhost:"+PORT+url);
            // Add headers from HttpExchange to OkHttp Request
            for (Map.Entry<String, List<String>> entry : exchange.getRequestHeaders().entrySet()) {
                for (String value : entry.getValue()) {
                    requestBuilder.addHeader(entry.getKey(), value);
                }
            }
            // If the method has a body, add it to the OkHttp Request
            if (method.equalsIgnoreCase("POST") || method.equalsIgnoreCase("PUT")) {
                byte[] bodyBytes = readAllBytes(exchange.getRequestBody());
                String body = new String(bodyBytes, StandardCharsets.UTF_8);
                RequestBody requestBody = RequestBody.create(
                    MediaType.parse(exchange.getRequestHeaders().getFirst("Content-Type")),
                    body
                );
                requestBuilder.method(method, requestBody);
            }
            return requestBuilder.build();
        }catch(Exception e){
            System.out.println(e);
            return null;
        }
    }
    
    private static byte[] readAllBytes(InputStream inputStream) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        int bytesRead;
        byte[] data = new byte[1024];
        while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
            buffer.write(data, 0, bytesRead);
        }
        return buffer.toByteArray();
    }

    private static void sendResponseToExchange(mResponse response, HttpExchange exchange) throws IOException {
        try{
            // 获取body
            byte[] responseBodyBytes = JsonUtils.object2Json(response).getBytes();

            // 设置状态码
            exchange.sendResponseHeaders(200, responseBodyBytes.length);

            // 设置响应体
            OutputStream os = exchange.getResponseBody();
            os.write(responseBodyBytes);
            os.close();
        }catch(Exception e){
            System.out.println(e);
        }
    }
}

```

#### 无update版本

```java
package com.openfaas.function.proxy;

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;

import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.MediaType;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.InputStream;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import edu.fudan.common.util.JsonUtils;
import edu.fudan.common.util.mResponse;

import com.openfaas.function.handler.Handler;

public class Proxy {
    private static final int PORT = 8080;
    private static final int MAX_REQUESTS = 3;
    private static final AtomicInteger requestCount = new AtomicInteger(0);

    public static void main(String[] args) throws IOException {
        // 创建HttpServer实例并绑定到特定地址和端口
        HttpServer server = HttpServer.create(new InetSocketAddress(PORT), 0);

        // 创建一个上下文，并指定处理器
        server.createContext("/", new InvokeHandler());

        // 设置服务器的线程池
        server.setExecutor(null);

        // 启动服务器
        server.start();

        System.out.println("Server is listening on port " + PORT + " with MAX_REQUESTS = " + MAX_REQUESTS);
    }

    // 定义处理器类
    static class InvokeHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            int currentCount = requestCount.incrementAndGet();

            // 将exchange转换成okhttp的Request
            Request request = httpExchangeToRequest(exchange);
            
            // 创建Handler实例并处理请求
            Handler handler = new Handler();
            mResponse mRes = handler.Handle(request);

            // 将mReponse转换成exchange进行输出
            sendResponseToExchange(mRes, exchange);
            if (currentCount >= MAX_REQUESTS) {
                exchange.getHttpContext().getServer().stop(0);
                System.out.println("Server stopped after " + currentCount + " requests");
            }
        }
    }

    public static Request httpExchangeToRequest(HttpExchange exchange) throws IOException {
        String method = exchange.getRequestMethod();
        String url = exchange.getRequestURI().toString();
        try{
            Request.Builder requestBuilder = new Request.Builder().url("http://locoalhost:"+PORT+url);
            // Add headers from HttpExchange to OkHttp Request
            for (Map.Entry<String, List<String>> entry : exchange.getRequestHeaders().entrySet()) {
                for (String value : entry.getValue()) {
                    requestBuilder.addHeader(entry.getKey(), value);
                }
            }
            // If the method has a body, add it to the OkHttp Request
            if (method.equalsIgnoreCase("POST") || method.equalsIgnoreCase("PUT")) {
                byte[] bodyBytes = readAllBytes(exchange.getRequestBody());
                String body = new String(bodyBytes, StandardCharsets.UTF_8);
                RequestBody requestBody = RequestBody.create(
                    MediaType.parse(exchange.getRequestHeaders().getFirst("Content-Type")),
                    body
                );
                requestBuilder.method(method, requestBody);
            }
            return requestBuilder.build();
        }catch(Exception e){
            System.out.println(e);
            return null;
        }
    }
    
    private static byte[] readAllBytes(InputStream inputStream) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        int bytesRead;
        byte[] data = new byte[1024];
        while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
            buffer.write(data, 0, bytesRead);
        }
        return buffer.toByteArray();
    }

    private static void sendResponseToExchange(mResponse response, HttpExchange exchange) throws IOException {
        try{
            // 获取body
            byte[] responseBodyBytes = JsonUtils.object2Json(response).getBytes();

            // 设置状态码
            exchange.sendResponseHeaders(200, responseBodyBytes.length);

            // 设置响应体
            OutputStream os = exchange.getResponseBody();
            os.write(responseBodyBytes);
            os.close();
        }catch(Exception e){
            System.out.println(e);
        }
    }
}
```
### 修改mongodb相关代码

在`repository`目录下，修改连接的地址。
```
MongoClient mongoClient = MongoClients.create("mongodb://172.17.0.1:27017");
```
### 修改Handler代码

增加导入的包
```java
import okhttp3.Request;
import okhttp3.RequestBody;
import okio.Buffer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
```
Handler类不用独立
```java
public class Handler{
}
```

返回值类型改为`mRespose`，传入值类型改为`Request`
```java
public mResponse Handle(Request req) {
}
```
#### 解析url

如果不是解析body的request，比如提取url的最后一个内容，可以参考以下内容：
```java
public mResponse Handle(Request req) {
	// 获取url的最后一个segment，即orderId
	List<String> segmentsList = req.url().pathSegments();
	String orderId = segmentsList.get(segmentsList.size()-1);
	System.out.println("OrderId: " + orderId);
}
```

#### 解析body

先增加`requestBodyToString`函数，之后将req的Body转换成String，替换json2Object的第一个参数。

```java
private OrderService orderService = new OrderServiceImpl();

public mResponse Handle(Request req) {
	String reqBody = requestBodyToString(req.body());
	Order orderInfo = JsonUtils.json2Object(reqBody, Order.class);
	mResponse mRes = orderService.saveChanges(orderInfo);

	return mRes;
}

private static String requestBodyToString(RequestBody requestBody) {
	try {
		if (requestBody == null) {
			return null;
		}
		Buffer buffer = new Buffer();
		requestBody.writeTo(buffer);
		return buffer.readUtf8();
	} catch (IOException e) {
		e.printStackTrace();
		return null;
	}
}
```
#### update

如果是最下游函数，去掉`UpdateHandle`静态方法。
如果不是最下游函数，需要在调用下游函数的类，比如`OrderServiceImpl`中修改所有URI为静态变量，之后增加一个静态方法`updateFunctionURI`。
```java
// OrderServiceImpl.java
public class OrderServiceImpl implements OrderService {
	public static String function44_URI = "";
	public static void updateFunctionURI(String _function44_URI){
		function44_URI = _function44_URI;
	}
}
```

```java
// Handler.java
public class Handler{
	public static mResponse UpdateHandle(Request req) {
        try{
            String reqBody = requestBodyToString(req.body());
            
            ObjectMapper mapper = new ObjectMapper();
            // 将字符串解析为JsonNode
            JsonNode rootNode = mapper.readTree(reqBody);
            String function44_URI = rootNode.get("function44_URI").asText();
            // 调用静态方法更新function URI
            OrderServiceImpl.updateFunctionURI(function44_URI);
            
            System.out.println("update URI success");

            return new mResponse(1, reqBody, null);
        } catch (Exception e) {
            e.printStackTrace();
            return new mResponse(0, e.getMessage(), null);
        }
    }

    private static String requestBodyToString(RequestBody requestBody) throws IOException {
        if (requestBody == null) {
            return null;
        }
        Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return buffer.readUtf8();
    }
}
```

#### 完整内容

```java
// 带有update的Handler.java
package com.openfaas.function.handler;

import java.io.IOException;

import okhttp3.Request;
import okhttp3.RequestBody;
import okio.Buffer;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.openfaas.function.entity.OrderInfo;
import com.openfaas.function.service.OrderService;
import com.openfaas.function.service.OrderServiceImpl;

import edu.fudan.common.util.JsonUtils;
import edu.fudan.common.util.mResponse;


public class Handler{

    private OrderService orderService = new OrderServiceImpl();

    public mResponse Handle(Request req) {
        try {
            String reqBody = requestBodyToString(req.body());
                        
            OrderInfo info = JsonUtils.json2Object(reqBody, OrderInfo.class);
            mResponse mRes = orderService.queryOrdersForRefresh(info,info.getLoginId());
            return mRes;
        } catch (Exception e) {
            e.printStackTrace();
            return new mResponse(0, e.getMessage(), null);
        }
    }

    public static mResponse UpdateHandle(Request req) {
        try{
            String reqBody = requestBodyToString(req.body());
            
            ObjectMapper mapper = new ObjectMapper();
            // 将字符串解析为JsonNode
            JsonNode rootNode = mapper.readTree(reqBody);
            String function44_URI = rootNode.get("function44_URI").asText();
            // 调用静态方法更新function URI
            OrderServiceImpl.updateFunctionURI(function44_URI);
            
            System.out.println("update URI success");

            return new mResponse(1, reqBody, null);
        } catch (Exception e) {
            e.printStackTrace();
            return new mResponse(0, e.getMessage(), null);
        }
    }

    private static String requestBodyToString(RequestBody requestBody) throws IOException {
        if (requestBody == null) {
            return null;
        }
        Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return buffer.readUtf8();
    }
}

```

```java
// 不带update的Handler.java
package com.openfaas.function.handler;

import com.openfaas.function.entity.Order;
import com.openfaas.function.service.OrderService;
import com.openfaas.function.service.OrderServiceImpl;

import edu.fudan.common.util.JsonUtils;
import edu.fudan.common.util.mResponse;

import okhttp3.Request;
import okhttp3.RequestBody;
import okio.Buffer;

import java.io.IOException;

public class Handler{

    private OrderService orderService = new OrderServiceImpl();

    public mResponse Handle(Request req) {
        String reqBody = requestBodyToString(req.body());
        Order orderInfo = JsonUtils.json2Object(reqBody, Order.class);
        mResponse mRes = orderService.saveChanges(orderInfo);

        return mRes;
    }

    private static String requestBodyToString(RequestBody requestBody) {
        try {
            if (requestBody == null) {
                return null;
            }
            Buffer buffer = new Buffer();
            requestBody.writeTo(buffer);
            return buffer.readUtf8();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}

```
## 3. 构建Docker

Dockerfile：
`function.jar`需要根据具体的函数名修改，即最上层的目录名。
```Dockerfile
# Use an official OpenJDK runtime as a parent image
FROM openjdk:8-jre-slim

# Set the working directory in the container
WORKDIR /app

# Copy the built JAR file to the container
COPY build/libs/function.jar /app/server.jar

# Expose the port that the app runs on
EXPOSE 8080

# Run the JAR file
ENTRYPOINT ["java", "-jar", "server.jar"]
```

构建&运行：
==构建之前需要先执行`./gradlew build`来生成jar包。==
```shell
docker build -t <image_name> .
docker run <image_name>
```


## 测试
==测试前确保mongoDB已经配置完成，需要的collection已经创建了==
先在本地测试通过，再在dokcer中测试。

使用`./gradlew run`运行java程序，最好测试一下jar包能否运行。

发送http请求
```
curl -X POST "http://localhost:8080/invoke" \
    -H "Content-Type: application/json" \
    -d '{"key": "value"}'
```

==注意`funciton_URI`不要增加`http://`==
==注意function_URI中的数字为两位，比如7要写成function07_URI==
```
curl -X POST "http://172.17.0.2:8080/update" \
    -H "Content-Type: application/json" \
    -d '{"function23_URI": "172.17.0.3:8080"}'
```

查看docker url
```shell
docker inspect --format='{{.Name}} - {{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -aq)
```

### 获取调用参数

通过js来查看相关函数的启动信息，比如下面，之后用在线js生成查看对应的json。
发现还差一个client_id，之后在函数中这个信息其实是account_id，之后在对应的mongodb的collection中找到account_id进行替换。

```js
var myOrdersQueryInfo = new Object();
myOrdersQueryInfo.loginId = sessionStorage.getItem("client_id");
myOrdersQueryInfo.enableStateQuery = false;
myOrdersQueryInfo.enableTravelDateQuery = false;
myOrdersQueryInfo.enableBoughtDateQuery = false;
myOrdersQueryInfo.travelDateStart = null;
myOrdersQueryInfo.travelDateEnd = null;
myOrdersQueryInfo.boughtDateStart = null;
myOrdersQueryInfo.boughtDateEnd = null;

this.myOrderList = [];
var myOrdersQueryData = JSON.stringify(myOrdersQueryInfo);
console.log(myOrdersQueryData)
```

下游函数通过上游的调用来构造。